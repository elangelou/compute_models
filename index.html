<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Safety Research — Compute Intensiveness Across AGI Timeline Scenarios</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <style>
    /* ── Tokens ─────────────────────────────────────────────────────────────── */
    :root {
      --bg:       #07080f;
      --bg1:      #0d0f1c;
      --bg2:      #111525;
      --bg3:      #181d30;
      --border:   #1e2540;
      --border2:  #252d4a;
      --text:     #e8edf5;
      --text2:    #8892b0;
      --text3:    #525f80;
      --indigo:   #6366f1;
      --indigo2:  #818cf8;
      --indigo3:  #4f46e5;
      --red:      #ef4444;
      --amber:    #f59e0b;
      --mono:     'SF Mono','JetBrains Mono','Fira Code','Cascadia Code',monospace;
    }

    /* ── Reset ──────────────────────────────────────────────────────────────── */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html { scroll-behavior: smooth; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', system-ui, sans-serif;
      line-height: 1.6;
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
    }

    /* ── Layout shell ───────────────────────────────────────────────────────── */
    .shell { max-width: 1300px; margin: 0 auto; padding: 0 1.75rem; }

    /* ── Header ─────────────────────────────────────────────────────────────── */
    header { padding: 3rem 0 0; }
    .header-kicker {
      display: inline-flex; align-items: center; gap: 0.5rem;
      font-size: 0.7rem; font-weight: 600; letter-spacing: 0.12em;
      text-transform: uppercase; color: var(--indigo2);
      background: rgba(99,102,241,.1); border: 1px solid rgba(99,102,241,.25);
      border-radius: 99px; padding: 0.25rem 0.75rem; margin-bottom: 1rem;
    }
    .header-kicker svg { flex-shrink: 0; }
    h1 {
      font-size: clamp(1.5rem, 3vw, 2.2rem);
      font-weight: 800; line-height: 1.15; letter-spacing: -0.02em;
      background: linear-gradient(120deg, #e8edf5 20%, #818cf8 80%);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      background-clip: text; margin-bottom: 0.85rem;
    }
    .header-sub {
      max-width: 780px; font-size: 0.9rem; color: var(--text2);
      line-height: 1.7; margin-bottom: 1.6rem;
    }
    .header-sub a { color: var(--indigo2); text-decoration: none; }
    .header-sub a:hover { text-decoration: underline; }

    /* ── Framework params ───────────────────────────────────────────────────── */
    .fw-row {
      display: flex; flex-wrap: wrap; gap: 0.5rem;
      margin-bottom: 2rem; padding-bottom: 1.75rem;
      border-bottom: 1px solid var(--border);
    }
    .fw-pill {
      display: flex; flex-direction: column; gap: 0.1rem;
      background: var(--bg2); border: 1px solid var(--border);
      border-radius: 8px; padding: 0.55rem 0.9rem;
    }
    .fw-pill-label {
      font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.1em;
      color: var(--text3); font-weight: 600;
    }
    .fw-pill-val {
      font-size: 0.82rem; font-weight: 700; color: var(--indigo2);
      font-family: var(--mono);
    }

    /* ── Tabs ───────────────────────────────────────────────────────────────── */
    .tab-bar {
      display: flex; gap: 0.2rem; margin-bottom: 1.5rem;
      border-bottom: 1px solid var(--border); overflow-x: auto;
      scrollbar-width: none;
    }
    .tab-bar::-webkit-scrollbar { display: none; }
    .tab {
      flex-shrink: 0; padding: 0.6rem 1.1rem;
      border: none; background: transparent;
      color: var(--text2); font-size: 0.82rem; font-weight: 500;
      cursor: pointer; border-bottom: 2px solid transparent;
      border-radius: 6px 6px 0 0; transition: all 0.15s; white-space: nowrap;
    }
    .tab:hover { color: var(--text); background: var(--bg2); }
    .tab.on { color: var(--indigo2); border-bottom-color: var(--indigo); background: var(--bg2); }
    .tab .tab-year {
      display: inline-block; margin-left: 0.35rem;
      font-size: 0.7rem; font-family: var(--mono);
      color: var(--indigo2); opacity: 0.7;
    }

    .pane { display: none; }
    .pane.on { display: block; }

    /* ── Scenario header strip ──────────────────────────────────────────────── */
    .sc-strip {
      display: flex; align-items: center; gap: 1rem;
      margin-bottom: 1.1rem; flex-wrap: wrap;
    }
    .sc-badge {
      font-size: 0.7rem; font-weight: 700; letter-spacing: 0.08em;
      text-transform: uppercase; padding: 0.25rem 0.7rem;
      border-radius: 5px; border: 1px solid;
    }
    .sc-badge.urgent   { color: #fca5a5; background: rgba(239,68,68,.12); border-color: rgba(239,68,68,.3); }
    .sc-badge.medium   { color: #c4b5fd; background: rgba(139,92,246,.12); border-color: rgba(139,92,246,.3); }
    .sc-badge.long-tl  { color: #93c5fd; background: rgba(59,130,246,.12); border-color: rgba(59,130,246,.3); }
    .sc-title  { font-size: 1.05rem; font-weight: 700; color: var(--text); }
    .sc-detail { font-size: 0.8rem; color: var(--text3); }

    /* ── Insight callout ────────────────────────────────────────────────────── */
    .insight {
      display: flex; gap: 0.75rem; align-items: flex-start;
      background: rgba(99,102,241,.07); border: 1px solid rgba(99,102,241,.2);
      border-left: 3px solid var(--indigo); border-radius: 8px;
      padding: 0.85rem 1.1rem; margin-bottom: 1.1rem;
      font-size: 0.82rem; color: var(--text2); line-height: 1.65;
    }
    .insight strong { color: var(--indigo2); }
    .insight-icon { flex-shrink: 0; margin-top: 0.15rem; color: var(--indigo2); }

    /* ── Controls ───────────────────────────────────────────────────────────── */
    .ctrl-bar {
      display: flex; align-items: center; gap: 1rem;
      margin-bottom: 0.75rem; flex-wrap: wrap;
    }
    .ctrl-label {
      font-size: 0.68rem; text-transform: uppercase; letter-spacing: 0.09em;
      color: var(--text3); font-weight: 600;
    }
    .tog-grp {
      display: flex; background: var(--bg2);
      border: 1px solid var(--border2); border-radius: 7px; overflow: hidden;
    }
    .tog {
      padding: 0.32rem 0.85rem; border: none;
      background: transparent; color: var(--text2);
      font-size: 0.75rem; font-weight: 500; cursor: pointer;
      transition: background 0.12s, color 0.12s;
    }
    .tog + .tog { border-left: 1px solid var(--border2); }
    .tog.on { background: var(--indigo3); color: #fff; }
    .tog:not(.on):hover { background: var(--bg3); color: var(--text); }

    /* ── Chart box ──────────────────────────────────────────────────────────── */
    .chart-wrap {
      background: var(--bg1); border: 1px solid var(--border);
      border-radius: 12px; overflow: hidden;
      padding: 0.75rem 0.5rem 0.5rem; margin-bottom: 1rem;
    }
    .chart-wrap > div { height: 540px !important; }

    /* ── Context table at AGI year ──────────────────────────────────────────── */
    .ctx-section {
      background: var(--bg2); border: 1px solid var(--border);
      border-radius: 10px; padding: 1rem 1.2rem; margin-bottom: 1.25rem;
    }
    .ctx-header {
      display: flex; align-items: baseline; gap: 0.6rem;
      margin-bottom: 0.85rem;
    }
    .ctx-title {
      font-size: 0.78rem; font-weight: 700; color: var(--text);
      text-transform: uppercase; letter-spacing: 0.06em;
    }
    .ctx-subtitle { font-size: 0.72rem; color: var(--text3); }
    .ctx-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
      gap: 0.6rem;
    }
    .ctx-card {
      background: var(--bg3); border: 1px solid var(--border2);
      border-radius: 8px; padding: 0.65rem 0.85rem;
      border-left: 2px solid;
    }
    .ctx-task { font-size: 0.73rem; font-weight: 600; margin-bottom: 0.45rem; }
    .ctx-rows { display: flex; flex-direction: column; gap: 0.2rem; }
    .ctx-row { display: flex; justify-content: space-between; align-items: baseline; gap: 0.5rem; }
    .ctx-row-label { font-size: 0.62rem; color: var(--text3); text-transform: uppercase; letter-spacing: 0.06em; flex-shrink: 0; }
    .ctx-row-val { font-size: 0.72rem; font-weight: 600; font-family: var(--mono); }

    /* ── Scenario description ───────────────────────────────────────────────── */
    .sc-desc {
      background: var(--bg2); border: 1px solid var(--border);
      border-radius: 10px; padding: 1rem 1.2rem; margin-bottom: 1.25rem;
    }
    .sc-desc h3 { font-size: 0.82rem; font-weight: 700; margin-bottom: 0.4rem; color: var(--text); }
    .sc-desc p  { font-size: 0.8rem; color: var(--text2); line-height: 1.7; }
    .sc-desc em { font-style: normal; font-weight: 600; color: var(--text); }

    /* ── Task cards ─────────────────────────────────────────────────────────── */
    .task-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 0.85rem; margin-bottom: 2.5rem;
    }
    .tcard {
      background: var(--bg2); border: 1px solid var(--border);
      border-left: 3px solid; border-radius: 10px; padding: 1rem 1.15rem;
      transition: border-color 0.15s, background 0.15s;
    }
    .tcard:hover { background: var(--bg3); }
    .tc-name { font-size: 0.85rem; font-weight: 700; margin-bottom: 0.15rem; }
    .tc-aka  { font-size: 0.7rem; color: var(--text3); margin-bottom: 0.5rem; font-style: italic; }
    .tc-desc { font-size: 0.76rem; color: var(--text2); margin-bottom: 0.7rem; line-height: 1.6; }
    .tc-bullets { list-style: none; display: flex; flex-direction: column; gap: 0.2rem; margin-bottom: 0.7rem; }
    .tc-bullets li {
      font-size: 0.73rem; color: var(--text2);
      padding-left: 0.9rem; position: relative; line-height: 1.5;
    }
    .tc-bullets li::before {
      content: '›'; position: absolute; left: 0;
      color: var(--text3); font-weight: 700;
    }
    .tc-meta { display: flex; gap: 1.2rem; border-top: 1px solid var(--border); padding-top: 0.65rem; }
    .tc-m { display: flex; flex-direction: column; gap: 0.05rem; }
    .tc-ml { font-size: 0.58rem; text-transform: uppercase; letter-spacing: 0.09em; color: var(--text3); font-weight: 600; }
    .tc-mv { font-size: 0.76rem; font-weight: 700; font-family: var(--mono); }
    .tc-note { font-size: 0.7rem; color: var(--text3); font-style: italic; margin-top: 0.45rem; }

    /* ── Methodology collapsible ────────────────────────────────────────────── */
    .method-wrap { margin-bottom: 2.5rem; }
    .method-toggle {
      width: 100%; background: var(--bg2); border: 1px solid var(--border);
      border-radius: 8px; padding: 0.75rem 1.1rem;
      display: flex; align-items: center; justify-content: space-between;
      font-size: 0.82rem; font-weight: 600; color: var(--text2);
      cursor: pointer; transition: background 0.12s, color 0.12s;
    }
    .method-toggle:hover { background: var(--bg3); color: var(--text); }
    .method-toggle .chevron { transition: transform 0.2s; color: var(--text3); }
    .method-toggle.open .chevron { transform: rotate(180deg); }
    .method-body {
      background: var(--bg2); border: 1px solid var(--border);
      border-top: none; border-radius: 0 0 8px 8px;
      padding: 1.1rem 1.2rem; display: none;
    }
    .method-body.open { display: block; }
    .method-body p { font-size: 0.8rem; color: var(--text2); line-height: 1.75; margin-bottom: 0.6rem; }
    .method-body p:last-child { margin-bottom: 0; }
    .method-body code {
      font-family: var(--mono); font-size: 0.78rem; color: var(--indigo2);
      background: rgba(99,102,241,.1); padding: 0.1em 0.35em; border-radius: 3px;
    }
    .method-body strong { color: var(--text); font-weight: 600; }

    /* ── Footer ─────────────────────────────────────────────────────────────── */
    footer {
      border-top: 1px solid var(--border); padding: 1.5rem 0 2.5rem;
      font-size: 0.73rem; color: var(--text3); line-height: 1.7;
    }
    footer a { color: var(--indigo2); text-decoration: none; }
    footer a:hover { text-decoration: underline; }

    /* ── Scrollbar ──────────────────────────────────────────────────────────── */
    ::-webkit-scrollbar { width: 5px; height: 5px; }
    ::-webkit-scrollbar-track { background: var(--bg); }
    ::-webkit-scrollbar-thumb { background: var(--border2); border-radius: 3px; }

    @media (max-width: 600px) {
      .shell { padding: 0 1rem; }
      h1 { font-size: 1.4rem; }
      .fw-row { gap: 0.4rem; }
    }
  </style>
</head>
<body>

<!-- ═══════════════════════════════ HEADER ══════════════════════════════════ -->
<header>
<div class="shell">
  <div class="header-kicker">
    <svg width="10" height="10" viewBox="0 0 10 10" fill="currentColor">
      <circle cx="5" cy="5" r="4.5" fill="none" stroke="currentColor" stroke-width="1"/>
      <circle cx="5" cy="5" r="1.5"/>
    </svg>
    AI Safety Research · Compute Analysis
  </div>
  <h1>Compute Intensiveness Across<br>AGI Timeline Scenarios</h1>
  <p class="header-sub">
    Three scenario models projecting how much compute (FLOPs) key AI safety research agendas will require,
    grounded in the <a href="https://epoch.ai/blog/a-compute-based-framework-for-thinking-about-the-future-of-ai"
    target="_blank" rel="noopener">Epoch AI effective compute framework</a>.
    Frontier training compute grows ~2.5× per year from a ~3×10²⁵ FLOP baseline in 2024.
    Algorithmic efficiency doubles every 9 months, compounding cost reductions for safety research.
    Task compute scales <em>sublinearly</em> with frontier via task-specific exponents (0.15–0.80).
    Click legend items to show/hide individual tasks. Use controls to toggle raw vs. effective compute.
  </p>

  <div class="fw-row">
    <div class="fw-pill">
      <span class="fw-pill-label">Frontier 2024</span>
      <span class="fw-pill-val">~3 × 10²⁵ FLOPs</span>
    </div>
    <div class="fw-pill">
      <span class="fw-pill-label">Frontier growth</span>
      <span class="fw-pill-val">~2.5× / year</span>
    </div>
    <div class="fw-pill">
      <span class="fw-pill-label">Algo efficiency</span>
      <span class="fw-pill-val">2× per 9 months</span>
    </div>
    <div class="fw-pill">
      <span class="fw-pill-label">Task scale exponents</span>
      <span class="fw-pill-val">0.15 – 0.80</span>
    </div>
    <div class="fw-pill">
      <span class="fw-pill-label">TAI compute est. (Epoch)</span>
      <span class="fw-pill-val">~10³² FLOPs (2023 algos)</span>
    </div>
    <div class="fw-pill">
      <span class="fw-pill-label">H100 GPU-year</span>
      <span class="fw-pill-val">≈ 6 × 10²² FLOPs</span>
    </div>
  </div>
</div>
</header>

<!-- ═══════════════════════════════ MAIN ════════════════════════════════════ -->
<main class="shell">

  <!-- Tabs -->
  <nav class="tab-bar">
    <button class="tab on" onclick="switchTab(0)">
      Short Timelines <span class="tab-year">AGI ≈ 2028</span>
    </button>
    <button class="tab" onclick="switchTab(1)">
      Medium Timelines <span class="tab-year">AGI ≈ 2035</span>
    </button>
    <button class="tab" onclick="switchTab(2)">
      Long Timelines <span class="tab-year">AGI ≈ 2055</span>
    </button>
  </nav>

  <!-- ══════════════════ SCENARIO 1 ══════════════════ -->
  <div class="pane on" id="pane-0">
    <div class="sc-strip">
      <span class="sc-badge urgent">Short — AGI ≈ 2028</span>
      <span class="sc-title">Pragmatic interpretability · Control AI · Red-teaming · Evaluations</span>
    </div>

    <div class="insight">
      <svg class="insight-icon" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
        <path d="M8 1a7 7 0 1 0 0 14A7 7 0 0 0 8 1Zm0 3.25a.75.75 0 1 1 0 1.5.75.75 0 0 1 0-1.5ZM7.25 7h1.5v4.5h-1.5V7Z"/>
      </svg>
      <span>
        <strong>Key insight:</strong> With only ~2 years of runway, safety compute requirements are already within reach
        of well-funded teams — but scale fast. The Control AI agenda has the tightest frontier coupling (exp 0.80):
        containment protocols <em>must</em> be tested against frontier-capable models, so cost tracks model capability almost linearly.
        Algorithmic improvements offer only modest relief in such a compressed window.
      </span>
    </div>

    <div class="ctrl-bar">
      <span class="ctrl-label">Compute type</span>
      <div class="tog-grp">
        <button class="tog on" id="c0-raw"  onclick="setType(0,'raw')">Raw FLOPs</button>
        <button class="tog"    id="c0-eff"  onclick="setType(0,'eff')">Effective FLOPs</button>
        <button class="tog"    id="c0-both" onclick="setType(0,'both')">Both</button>
      </div>
      <span class="ctrl-label" style="margin-left:.4rem">Frontier line</span>
      <div class="tog-grp">
        <button class="tog on" id="c0-fon"  onclick="setFrontier(0,true)">Show</button>
        <button class="tog"    id="c0-foff" onclick="setFrontier(0,false)">Hide</button>
      </div>
      <span class="ctrl-label" style="margin-left:.4rem">Reference lines</span>
      <div class="tog-grp">
        <button class="tog on" id="c0-ron"  onclick="setRefs(0,true)">Show</button>
        <button class="tog"    id="c0-roff" onclick="setRefs(0,false)">Hide</button>
      </div>
    </div>

    <div class="chart-wrap"><div id="chart-0"></div></div>

    <div class="ctx-section" id="ctx-0"></div>

    <div class="sc-desc">
      <h3>Scenario context</h3>
      <p>
        In a short-timeline world, safety work must be pragmatic and frontier-coupled.
        <em>Pragmatic interpretability</em> (Neel Nanda's agenda) involves training Sparse Autoencoders (SAEs)
        on frontier-scale models, running activation patching experiments, and scaling automated interpretability pipelines
        — all of which require inference access to the largest available models.
        <em>Control AI agenda</em> tasks (Evan Hubinger and collaborators) test whether AI systems can be reliably
        shut down, corrected, and overseen even when they have strong situational awareness — requiring genuine
        capability to be present in the test subject.
        <em>Red-teaming</em> stress-tests deployed models adversarially: finding jailbreaks, eliciting dangerous
        capabilities, and probing for deceptive alignment at deployment scale.
        <em>Evaluations</em> (METR, Apollo, ARC Evals-style) run capability benchmarks to track when models cross
        dangerous thresholds — covering an expanding model population at each release cycle.
      </p>
    </div>

    <div class="task-grid" id="cards-0"></div>
  </div>

  <!-- ══════════════════ SCENARIO 2 ══════════════════ -->
  <div class="pane" id="pane-1">
    <div class="sc-strip">
      <span class="sc-badge medium">Medium — AGI ≈ 2035</span>
      <span class="sc-title">Interpretability · Evaluations · Learning theory</span>
    </div>

    <div class="insight">
      <svg class="insight-icon" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
        <path d="M8 1a7 7 0 1 0 0 14A7 7 0 0 0 8 1Zm0 3.25a.75.75 0 1 1 0 1.5.75.75 0 0 1 0-1.5ZM7.25 7h1.5v4.5h-1.5V7Z"/>
      </svg>
      <span>
        <strong>Key insight:</strong> Switch to <strong>Both</strong> mode to see a compounding divergence between
        raw and effective FLOPs. By 2035, algorithmic efficiency gains (~1,000× cumulative since 2024) dramatically
        reduce actual cost — interpretability research that nominally requires 10²⁶ raw FLOPs may only need ~10²³
        effective FLOPs. This gap is the single biggest lever for making safety research tractable.
      </span>
    </div>

    <div class="ctrl-bar">
      <span class="ctrl-label">Compute type</span>
      <div class="tog-grp">
        <button class="tog on" id="c1-raw"  onclick="setType(1,'raw')">Raw FLOPs</button>
        <button class="tog"    id="c1-eff"  onclick="setType(1,'eff')">Effective FLOPs</button>
        <button class="tog"    id="c1-both" onclick="setType(1,'both')">Both</button>
      </div>
      <span class="ctrl-label" style="margin-left:.4rem">Frontier line</span>
      <div class="tog-grp">
        <button class="tog on" id="c1-fon"  onclick="setFrontier(1,true)">Show</button>
        <button class="tog"    id="c1-foff" onclick="setFrontier(1,false)">Hide</button>
      </div>
      <span class="ctrl-label" style="margin-left:.4rem">Reference lines</span>
      <div class="tog-grp">
        <button class="tog on" id="c1-ron"  onclick="setRefs(1,true)">Show</button>
        <button class="tog"    id="c1-roff" onclick="setRefs(1,false)">Hide</button>
      </div>
    </div>

    <div class="chart-wrap"><div id="chart-1"></div></div>

    <div class="ctx-section" id="ctx-1"></div>

    <div class="sc-desc">
      <h3>Scenario context</h3>
      <p>
        Medium timelines allow more structured foundational work, but all three agendas must still
        operate at frontier scale to remain relevant.
        <em>Interpretability</em> at this scale involves systematic mechanistic analysis of models far larger than
        today's frontier — SAE training on 10¹⁰+ parameter models, representation geometry mapping across
        modalities, and automated pipelines using capable AI to explain AI.
        <em>Evaluations</em> broaden in domain and fidelity: finer-grained elicitation of dangerous capabilities,
        multi-step reasoning evaluations, and deceptive alignment detection at scale.
        <em>Learning theory</em> begins to play a meaningful empirical role — deriving and validating
        generalisation bounds, PAC-Bayes analysis, and neural scaling laws requires running experiments on
        real large-scale architectures, though most work remains proof-based.
        Toggle <strong>Both</strong> to see how cumulative algorithmic efficiency could reduce the
        effective compute cost faster than raw costs grow for every agenda shown here.
      </p>
    </div>

    <div class="task-grid" id="cards-1"></div>
  </div>

  <!-- ══════════════════ SCENARIO 3 ══════════════════ -->
  <div class="pane" id="pane-2">
    <div class="sc-strip">
      <span class="sc-badge long-tl">Long — AGI ≈ 2055</span>
      <span class="sc-title">Learning theory · Computational complexity · Information theory · Cryptography</span>
    </div>

    <div class="insight">
      <svg class="insight-icon" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
        <path d="M8 1a7 7 0 1 0 0 14A7 7 0 0 0 8 1Zm0 3.25a.75.75 0 1 1 0 1.5.75.75 0 0 1 0-1.5ZM7.25 7h1.5v4.5h-1.5V7Z"/>
      </svg>
      <span>
        <strong>Key insight:</strong> Theory-heavy agendas (complexity, information theory) are nearly
        compute-independent — the frontier-to-task gap widens from ~10⁶ today to ~10¹⁶ by 2055,
        illustrating that <em>theoretical safety work remains tractable at any compute level</em>.
        A hardware ceiling assumed after 2040 (~1.4×/yr instead of 2.5×/yr) barely affects these agendas.
      </span>
    </div>

    <div class="ctrl-bar">
      <span class="ctrl-label">Compute type</span>
      <div class="tog-grp">
        <button class="tog on" id="c2-raw"  onclick="setType(2,'raw')">Raw FLOPs</button>
        <button class="tog"    id="c2-eff"  onclick="setType(2,'eff')">Effective FLOPs</button>
        <button class="tog"    id="c2-both" onclick="setType(2,'both')">Both</button>
      </div>
      <span class="ctrl-label" style="margin-left:.4rem">Frontier line</span>
      <div class="tog-grp">
        <button class="tog on" id="c2-fon"  onclick="setFrontier(2,true)">Show</button>
        <button class="tog"    id="c2-foff" onclick="setFrontier(2,false)">Hide</button>
      </div>
      <span class="ctrl-label" style="margin-left:.4rem">Reference lines</span>
      <div class="tog-grp">
        <button class="tog on" id="c2-ron"  onclick="setRefs(2,true)">Show</button>
        <button class="tog"    id="c2-roff" onclick="setRefs(2,false)">Hide</button>
      </div>
    </div>

    <div class="chart-wrap"><div id="chart-2"></div></div>

    <div class="ctx-section" id="ctx-2"></div>

    <div class="sc-desc">
      <h3>Scenario context</h3>
      <p>
        Long timelines open space for deep theoretical work that doesn't require running on frontier hardware.
        A hardware ceiling is assumed after 2040 as physical and economic scaling limits tighten,
        slowing frontier growth from ~2.5× to ~1.4× per year (amber dashed line on chart).
        <em>Learning theory</em> (generalisation bounds, PAC-Bayes, scaling law derivations) retains
        a modest empirical component — running validation experiments on real architectures — giving it
        an exponent of 0.42.
        <em>Computational complexity</em> (hardness results, query complexity of learning, reductions)
        is almost entirely proof-based: exp 0.18 means it barely scales with the frontier at all.
        <em>Information theory</em> (channel capacity, Kolmogorov complexity of neural networks,
        compression bounds) is similarly theoretical at exp 0.22.
        <em>Cryptography</em> (post-quantum lattice schemes, AI-robustness of deployed cryptosystems)
        scales slightly more at exp 0.32, as lattice computations benefit modestly from more FLOP availability.
      </p>
    </div>

    <div class="task-grid" id="cards-2"></div>
  </div>

  <!-- ══════════════════ METHODOLOGY ══════════════════ -->
  <div class="method-wrap">
    <button class="method-toggle" onclick="toggleMethod(this)">
      <span>Methodology &amp; framework assumptions</span>
      <svg class="chevron" width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="2,5 7,10 12,5"/>
      </svg>
    </button>
    <div class="method-body">
      <p>
        <strong>Frontier compute.</strong>
        We set a 2024 baseline of <code>F₀ = 3×10²⁵ FLOPs</code> (consistent with GPT-4/Gemini Ultra scale
        training runs documented by Epoch AI). Frontier compute grows as <code>F(t) = F₀ × 2.5^(t–2024)</code>.
        Scenario 3 uses a piecewise function: 2.5×/yr until 2040, then 1.4×/yr, modelling an assumed
        hardware ceiling as Moore's law slows and fab economics constrain production.
      </p>
      <p>
        <strong>Task compute (raw).</strong>
        Each research agenda has a 2024 baseline compute requirement and a frontier-scaling exponent.
        <code>C_raw(t) = base × (F(t)/F₀)^exp</code>.
        Exponents reflect how tightly a task must be coupled to frontier scale: 0.80 (Control AI —
        must test against genuinely capable models) down to 0.18 (complexity theory — mostly proof-based).
        Baselines represent order-of-magnitude estimates of a large annual research campaign.
      </p>
      <p>
        <strong>Effective compute.</strong>
        Algorithmic progress halves the compute needed for fixed task performance roughly every 9 months
        (Erdil &amp; Besiroglu 2022, as cited in the Epoch framework). The cumulative efficiency multiplier is
        <code>M(t) = 2^((t–2024)/0.75)</code>. Effective compute is <code>C_eff(t) = C_raw(t) / M(t)</code>.
        This models the actual FLOP cost after applying the best available training recipes at each future date.
      </p>
      <p>
        <strong>H100 reference lines.</strong>
        One H100 GPU at ~50% model FLOP utilisation delivers ≈ 2×10¹⁵ FLOPs/s, or approximately
        <code>6×10²² FLOPs/year</code>. Reference lines at 1, 100, and 10,000 H100-GPU-years are shown
        on each chart to anchor abstract FLOPs in operational reality.
        Cloud H100 costs ≈ $2–3/hr → ~$20,000/GPU-year.
      </p>
      <p>
        <strong>Uncertainty.</strong>
        All parameters carry significant uncertainty. Frontier growth has historically been ~4× per year;
        we use 2.5× as a conservative estimate. Algorithmic efficiency doubling could be faster or slower.
        Task scaling exponents are subjective estimates — treat all curves as illustrative order-of-magnitude
        projections, not predictions.
      </p>
    </div>
  </div>

</main>

<!-- ═══════════════════════════════ FOOTER ══════════════════════════════════ -->
<footer>
<div class="shell">
  Source: <a href="https://epoch.ai/blog/a-compute-based-framework-for-thinking-about-the-future-of-ai"
  target="_blank" rel="noopener">Epoch AI — A Compute-Based Framework for Thinking About the Future of AI</a>.
  Erdil &amp; Besiroglu (2022) for algorithmic efficiency doubling time.
  H100 throughput: Nvidia H100 SXM spec at ~50% MFU. Cloud cost: ~$2.50/GPU-hour.
  All projections are illustrative order-of-magnitude estimates with substantial uncertainty.
</div>
</footer>


<!-- ═══════════════════════════════ SCRIPT ══════════════════════════════════ -->
<script>
'use strict';

// ─── Epoch AI framework ──────────────────────────────────────────────────────
const F0            = 3e25;          // Frontier 2024
const F_GROWTH      = 2.5;           // ×/year
const ALGO_DBL      = 0.75;          // years (9 months)
const H100_YR       = 6e22;          // FLOPs per H100-GPU-year
const H100_USD_YR   = 20000;         // $ per H100-GPU-year (cloud rental)

function frontier(y)     { return F0 * Math.pow(F_GROWTH, y - 2024); }
function frontierLong(y) {
  if (y <= 2040) return frontier(y);
  return frontier(2040) * Math.pow(1.4, y - 2040);
}
function algoMul(y)   { return Math.pow(2, (y - 2024) / ALGO_DBL); }
function rawC(b,e,y,fn) { return b * Math.pow(fn(y) / F0, e); }
function effC(b,e,y,fn) { return rawC(b,e,y,fn) / algoMul(y); }

function range(a, b, n) {
  return Array.from({ length: n }, (_, i) => a + (b - a) * i / (n - 1));
}

// ─── Scenario definitions ────────────────────────────────────────────────────
const S = [
  // ── Scenario 1: Short (AGI 2028) ─────────────────────────────────────────
  {
    id: 0, agiYear: 2028, critStart: 2026.8,
    xRange: [2024, 2029.5], yRange: [5e18, 5e30],
    fn: frontier, hwCeil: null,
    tasks: [
      {
        label: 'Pragmatic Interpretability',
        aka:   "Neel Nanda's agenda — circuits, SAEs, automated interp",
        desc:  'Understanding what computations frontier models perform through mechanistic analysis. Includes SAE training, activation patching, circuit discovery, and automated interpretability pipelines.',
        bullets: [
          'Sparse Autoencoder (SAE) training on frontier-scale models (~10²³ FLOPs/run)',
          'Activation patching across thousands of prompts to identify circuits',
          'Automated interpretability: using capable AI to label SAE features at scale',
          'Linear representation hypothesis validation across architectures',
        ],
        base: 8e21, exp: 0.72, color: '#ff6b6b',
        note: 'exp 0.72 — SAE training and activation patching must scale with frontier model size'
      },
      {
        label: 'Control AI Agenda',
        aka:   'Hubinger et al. — containment, oversight, corrigibility protocols',
        desc:  'Testing whether AI systems can be reliably shut down, corrected, and overseen even as capability and situational awareness grow. Requires genuine frontier-class test subjects.',
        bullets: [
          'Red-teaming control protocols against capable, strategically-aware models',
          'Testing shutdown, corrigibility, and tripwire robustness at scale',
          'Verifying that AI systems cannot circumvent oversight mechanisms',
          'Iterating protocols in response to capability jumps — requires frontier access',
        ],
        base: 4e22, exp: 0.80, color: '#ffa94d',
        note: 'exp 0.80 — strongest frontier coupling; protocols are only meaningful against capable AI'
      },
      {
        label: 'Red-teaming',
        aka:   'Adversarial capability elicitation and vulnerability discovery',
        desc:  'Systematically probing deployed models for dangerous capabilities, jailbreaks, and deceptive alignment signals. Inference-heavy but not training-dependent.',
        bullets: [
          'Large-scale jailbreak discovery and adversarial prompt generation',
          'Dangerous capability elicitation (bio, cyber, persuasion uplift)',
          'Detecting alignment faking and goal misgeneralization under distribution shift',
          'Multi-model adversarial pipelines (LLM vs LLM red-teaming)',
        ],
        base: 2e21, exp: 0.65, color: '#ffd43b',
        note: 'exp 0.65 — inference-heavy; scales with model size but not full training runs'
      },
      {
        label: 'Evaluations',
        aka:   'METR, Apollo, ARC-Evals style capability and safety assessments',
        desc:  'Capability benchmarks and safety assessments to track dangerous threshold crossings. Must cover an expanding model population across each release cycle.',
        bullets: [
          'Dangerous capability evaluations: autonomous replication, cyberoffense, CBRN uplift',
          'Behavioral consistency testing under distribution shift and context manipulation',
          'Scalable oversight benchmarks and debate evaluation',
          'Tracking emergence of novel capabilities across model generations',
        ],
        base: 5e20, exp: 0.60, color: '#69db7c',
        note: 'exp 0.60 — benchmark sweeps; lighter per-run but broad model population coverage required'
      },
    ]
  },

  // ── Scenario 2: Medium (AGI 2035) ────────────────────────────────────────
  {
    id: 1, agiYear: 2035, critStart: 2033,
    xRange: [2024, 2037], yRange: [1e16, 1e42],
    fn: frontier, hwCeil: null,
    tasks: [
      {
        label: 'Interpretability',
        aka:   'Systematic mechanistic analysis of large-scale models',
        desc:  'At 2035 frontier scale, interpretability requires studying models with potentially 10¹⁰+ parameters. SAE training, circuit discovery, and representation geometry analysis must all scale accordingly.',
        bullets: [
          'Training SAEs on models an order of magnitude beyond 2024 frontier scale',
          'Systematic representation geometry mapping across modalities and architectures',
          'Causal tracing and path patching at the scale of future models',
          'Using capable AI models to automatically explain and catalog features',
        ],
        base: 1e22, exp: 0.75, color: '#cc5de8',
        note: 'exp 0.75 — moderate-strong frontier coupling; target models keep growing'
      },
      {
        label: 'Evaluations',
        aka:   'Comprehensive capability and safety assessment programs',
        desc:  'Broader domain coverage, finer-grained elicitation, and more sophisticated behavioral testing as models become more capable and dangerous capability thresholds are approached.',
        bullets: [
          'Long-horizon autonomous task evaluations (multi-day agentic benchmarks)',
          'Sophisticated deceptive alignment detection protocols',
          'Cross-model consistency and behavioral fingerprinting at scale',
          'Scalable oversight evaluation: debate, amplification, and recursive reward modeling',
        ],
        base: 5e20, exp: 0.62, color: '#339af0',
        note: 'exp 0.62 — scales with number and size of models evaluated across the ecosystem'
      },
      {
        label: 'Learning Theory',
        aka:   'Empirical validation of generalisation bounds and scaling laws',
        desc:  'Deriving and validating generalisation bounds, PAC-Bayes analysis, and neural scaling law derivations on real large-scale architectures. Mixed theoretical and empirical workload.',
        bullets: [
          'Empirical validation of PAC-Bayes bounds on large language model training',
          'Neural scaling law derivations — testing theoretical predictions at scale',
          'Studying sharp phase transitions and emergent capabilities from first principles',
          'Formal verification of learning algorithms in simplified model classes',
        ],
        base: 3e19, exp: 0.47, color: '#20c997',
        note: 'exp 0.47 — mixed theory/empirical; validation on real models matters but isn\'t dominant'
      },
    ]
  },

  // ── Scenario 3: Long (AGI 2055) ──────────────────────────────────────────
  {
    id: 2, agiYear: 2055, critStart: 2050,
    xRange: [2024, 2057], yRange: [1e11, 5e37],
    fn: frontierLong, hwCeil: 2040,
    tasks: [
      {
        label: 'Learning Theory',
        aka:   'Generalisation bounds, PAC-Bayes, scaling derivations',
        desc:  'Long-horizon theoretical work on the mathematics of learning systems. Some empirical validation on large architectures, but primarily proof-based research with modest compute needs.',
        bullets: [
          'Deriving tight generalisation bounds for overparameterised transformer architectures',
          'PAC-Bayes analysis with frontier-scale validation experiments',
          'Formal study of neural scaling laws — why do power laws hold, and when do they break?',
          'Sample complexity theory for alignment-relevant task distributions',
        ],
        base: 3e19, exp: 0.42, color: '#4dabf7',
        note: 'exp 0.42 — moderate; theory-driven with a partial empirical validation component'
      },
      {
        label: 'Computational Complexity',
        aka:   'Hardness results, reductions, query complexity of learning',
        desc:  'Formal complexity-theoretic study of learning and reasoning. Almost entirely proof-based — the compute footprint is minimal regardless of frontier scale.',
        bullets: [
          'Hardness results for learning transformer circuits — what is computationally intractable?',
          'Query complexity of alignment-relevant task classes',
          'Cryptographic hardness assumptions as a foundation for AI safety guarantees',
          'Reductions between learning, verification, and oversight tasks',
        ],
        base: 5e15, exp: 0.18, color: '#38d9a9',
        note: 'exp 0.18 — near-compute-independent; formal proofs tractable at any compute level'
      },
      {
        label: 'Information Theory',
        aka:   'Capacity bounds, Kolmogorov complexity, compression',
        desc:  'Channel capacity theory, Kolmogorov complexity of neural network representations, and information-theoretic safety guarantees. Minimal experimental compute footprint.',
        bullets: [
          'Information-theoretic bounds on what safety properties can be verified externally',
          'Kolmogorov complexity of learned representations — how compressible is model knowledge?',
          'Channel capacity of human oversight as a bottleneck for AI alignment',
          'Minimum description length principles applied to neural architecture selection',
        ],
        base: 1e16, exp: 0.22, color: '#9775fa',
        note: 'exp 0.22 — mainly theoretical; small experimental component for empirical capacity bounds'
      },
      {
        label: 'Cryptography',
        aka:   'Post-quantum schemes, lattice-based, AI-robustness of cryptosystems',
        desc:  'Post-quantum cryptographic schemes, lattice-based constructions, and studying the robustness of deployed cryptosystems against AI-enabled adversaries. Lattice computations scale modestly.',
        bullets: [
          'Lattice-based cryptographic constructions hardened against AI-assisted attacks',
          'Post-quantum protocol verification — can AI help or break zero-knowledge proofs?',
          'Studying AI-assisted cryptanalysis: what does a frontier AI change about cryptographic assumptions?',
          'Cryptographic commitment schemes for verifiable oversight of AI systems',
        ],
        base: 8e17, exp: 0.32, color: '#f783ac',
        note: 'exp 0.32 — lattice computations and empirical testing scale modestly with FLOP availability'
      },
    ]
  }
];

// ─── UI state ─────────────────────────────────────────────────────────────────
const US = [
  { type: 'raw', frontier: true, refs: true },
  { type: 'raw', frontier: true, refs: true },
  { type: 'raw', frontier: true, refs: true },
];

// ─── H100 reference line definitions ─────────────────────────────────────────
const H100_REFS = [
  { v: 6e20,  label: '10 H100-years',    dash: 'dot',       color: 'rgba(148,163,184,.35)' },
  { v: 6e22,  label: '1,000 H100-years', dash: 'dot',       color: 'rgba(148,163,184,.35)' },
  { v: 6e24,  label: '100K H100-years',  dash: 'dot',       color: 'rgba(148,163,184,.35)' },
  { v: 6e26,  label: '10M H100-years',   dash: 'dot',       color: 'rgba(148,163,184,.35)' },
];

// ─── Build Plotly traces ──────────────────────────────────────────────────────
function buildTraces(s, type, showFrontier, showRefs) {
  const N     = 600;
  const years = range(s.xRange[0], s.xRange[1], N);
  const fn    = s.fn;
  const traces = [];

  // H100 reference lines
  if (showRefs) {
    for (const ref of H100_REFS) {
      if (ref.v < s.yRange[0] * 0.5 || ref.v > s.yRange[1] * 2) continue;
      traces.push({
        x: [s.xRange[0], s.xRange[1]], y: [ref.v, ref.v],
        name: ref.label, mode: 'lines',
        line: { color: ref.color, width: 1, dash: ref.dash },
        hovertemplate: `<b>${ref.label}</b><br>= ${ref.v.toExponential(0)} FLOPs<extra></extra>`,
        showlegend: true, legendrank: -10,
      });
    }
  }

  // Frontier reference
  if (showFrontier) {
    traces.push({
      x: years, y: years.map(y => fn(y)),
      name: 'Frontier training compute',
      mode: 'lines',
      line: { color: '#475569', width: 1.8, dash: 'dash' },
      hovertemplate: '<b>Frontier</b><br>%{x:.2f}  →  %{y:.2e} FLOPs<extra></extra>',
      legendrank: 1,
    });
  }

  // Task traces
  for (const t of s.tasks) {
    const rY = years.map(y => rawC(t.base, t.exp, y, fn));
    const eY = years.map(y => effC(t.base, t.exp, y, fn));
    const frontierY = years.map(y => fn(y));

    // Build customdata: [h100Years_raw, pct_frontier_raw, h100Years_eff, pct_frontier_eff, algoMul]
    const cdRaw = years.map((y, i) => [
      (rY[i] / H100_YR).toPrecision(2),
      ((rY[i] / frontierY[i]) * 100).toPrecision(2),
      Math.round(rY[i] / H100_YR * H100_USD_YR / 1e3),
    ]);
    const cdEff = years.map((y, i) => [
      (eY[i] / H100_YR).toPrecision(2),
      ((eY[i] / frontierY[i]) * 100).toPrecision(2),
      Math.round(eY[i] / H100_YR * H100_USD_YR / 1e3),
      algoMul(y).toPrecision(3),
    ]);

    if (type === 'raw' || type === 'both') {
      traces.push({
        x: years, y: rY, customdata: cdRaw,
        name: t.label + (type === 'both' ? ' (raw)' : ''),
        mode: 'lines',
        line: { color: t.color, width: 2.8 },
        legendgroup: t.label,
        hovertemplate:
          `<b>${t.label}</b>` +
          `<br>Year: %{x:.1f}` +
          `<br>Raw compute: <b>%{y:.2e}</b> FLOPs` +
          `<br>≈ %{customdata[0]} H100-GPU-years` +
          `<br>≈ $%{customdata[2]}K (cloud)` +
          `<br>= %{customdata[1]}% of frontier` +
          `<extra></extra>`,
      });
    }

    if (type === 'eff' || type === 'both') {
      traces.push({
        x: years, y: eY, customdata: cdEff,
        name: t.label + (type === 'both' ? ' (effective)' : ''),
        mode: 'lines',
        line: { color: t.color, width: type === 'both' ? 1.5 : 2.8, dash: 'dot' },
        opacity: type === 'both' ? 0.55 : 1,
        legendgroup: t.label,
        showlegend: type !== 'both',
        hovertemplate:
          `<b>${t.label} (effective)</b>` +
          `<br>Year: %{x:.1f}` +
          `<br>Effective compute: <b>%{y:.2e}</b> FLOPs` +
          `<br>≈ %{customdata[0]} H100-GPU-years` +
          `<br>≈ $%{customdata[2]}K (cloud)` +
          `<br>= %{customdata[1]}% of frontier` +
          `<br>÷ algo-efficiency ×%{customdata[3]}` +
          `<extra></extra>`,
      });
    }
  }

  return traces;
}

// ─── Build Plotly layout ──────────────────────────────────────────────────────
function buildLayout(s) {
  const yMin = Math.log10(s.yRange[0]);
  const yMax = Math.log10(s.yRange[1]);

  const shapes = [
    // Critical window shading
    {
      type: 'rect', xref: 'x', yref: 'paper',
      x0: s.critStart, x1: s.agiYear, y0: 0, y1: 1,
      fillcolor: 'rgba(239,68,68,.055)', line: { width: 0 }, layer: 'below',
    },
    // AGI milestone line
    {
      type: 'line', xref: 'x', yref: 'paper',
      x0: s.agiYear, x1: s.agiYear, y0: 0, y1: 1,
      line: { color: '#ef4444', width: 1.8, dash: 'dot' },
    },
  ];

  if (s.hwCeil) {
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: s.hwCeil, x1: s.hwCeil, y0: 0, y1: 1,
      line: { color: '#f59e0b', width: 1.3, dash: 'longdash' },
    });
  }

  const annotations = [
    {
      x: s.agiYear - 0.06, y: 0.96,
      xref: 'x', yref: 'paper',
      text: `<b>AGI ≈ ${s.agiYear}</b>`,
      showarrow: false, xanchor: 'right',
      font: { color: '#fca5a5', size: 10.5, family: 'monospace' },
      bgcolor: 'rgba(15,5,5,.82)', bordercolor: '#ef4444', borderwidth: 1, borderpad: 4,
    },
    {
      x: s.critStart + (s.agiYear - s.critStart) / 2, y: 0.015,
      xref: 'x', yref: 'paper',
      text: 'critical window', showarrow: false,
      font: { color: 'rgba(239,68,68,.4)', size: 8, family: 'monospace' }, xanchor: 'center',
    },
  ];

  if (s.hwCeil) {
    annotations.push({
      x: s.hwCeil + 0.5, y: 0.06,
      xref: 'x', yref: 'paper',
      text: 'hardware ceiling<br>growth → 1.4×/yr',
      showarrow: false, xanchor: 'left',
      font: { color: 'rgba(245,158,11,.65)', size: 8.5 },
    });
  }

  return {
    paper_bgcolor: '#0d0f1c',
    plot_bgcolor:  '#07080f',
    font: { color: '#8892b0', family: '-apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif', size: 11 },
    xaxis: {
      title: { text: 'Year', font: { size: 12, color: '#8892b0' } },
      range: s.xRange, tickformat: 'd',
      gridcolor: '#111525', gridwidth: 1, zeroline: false,
      linecolor: '#1e2540', tickcolor: '#1e2540',
      color: '#525f80', tickfont: { size: 10 },
    },
    yaxis: {
      title: { text: 'Compute per research campaign (FLOPs)', font: { size: 12, color: '#8892b0' } },
      type: 'log', range: [yMin, yMax],
      gridcolor: '#111525', gridwidth: 1, zeroline: false,
      linecolor: '#1e2540', color: '#525f80', tickfont: { size: 10 },
      exponentformat: 'power', dtick: 3,
    },
    legend: {
      bgcolor: 'rgba(13,15,28,.92)', bordercolor: '#1e2540', borderwidth: 1,
      font: { size: 9.5 }, x: 0.01, y: 0.99, xanchor: 'left', yanchor: 'top',
      tracegroupgap: 1,
    },
    margin: { l: 90, r: 45, t: 14, b: 60 },
    shapes, annotations,
    hovermode: 'x unified',
    hoverlabel: {
      bgcolor: '#111525', bordercolor: '#252d4a',
      font: { color: '#e8edf5', size: 11 },
      namelength: 40,
    },
  };
}

// ─── Render chart ─────────────────────────────────────────────────────────────
function renderChart(id) {
  const s  = S[id];
  const st = US[id];
  Plotly.react(
    `chart-${id}`,
    buildTraces(s, st.type, st.frontier, st.refs),
    buildLayout(s),
    {
      responsive: true, displayModeBar: true, displaylogo: false,
      modeBarButtonsToRemove: ['select2d', 'lasso2d', 'autoScale2d'],
      toImageButtonOptions: { filename: `ai_safety_compute_s${id+1}`, scale: 2, format: 'png' },
    }
  );
}

// ─── Render AGI-year context table ────────────────────────────────────────────
function renderContext(id) {
  const s  = S[id];
  const fn = s.fn;
  const y  = s.agiYear;
  const fv = fn(y);
  const am = algoMul(y);

  let html = `
    <div class="ctx-header">
      <span class="ctx-title">Compute at AGI Year (${y})</span>
      <span class="ctx-subtitle">
        frontier = ${fv.toExponential(1)} FLOPs &nbsp;·&nbsp; algo efficiency = ×${am.toFixed(0)} vs 2024
      </span>
    </div>
    <div class="ctx-grid">
  `;

  for (const t of s.tasks) {
    const raw = rawC(t.base, t.exp, y, fn);
    const eff = effC(t.base, t.exp, y, fn);
    const pctF = (raw / fv * 100);
    const h100raw = raw / H100_YR;
    const h100eff = eff / H100_YR;
    const costRaw = Math.round(h100raw * H100_USD_YR / 1e6 * 10) / 10;
    const costEff = Math.round(h100eff * H100_USD_YR / 1e6 * 10) / 10;

    function fmtH100(v) {
      if (v < 1)    return '< 1';
      if (v < 1e3)  return v.toFixed(0);
      if (v < 1e6)  return (v/1e3).toFixed(1) + 'K';
      return (v/1e6).toFixed(2) + 'M';
    }
    function fmtCost(m) {
      if (m < 0.01) return '< $10K';
      if (m < 1)    return '$' + (m*1000).toFixed(0) + 'K';
      return '$' + m.toFixed(1) + 'M';
    }
    function fmtPct(p) {
      if (p < 0.0001) return '< 0.0001%';
      if (p < 0.01)   return p.toExponential(1) + '%';
      return p.toFixed(3) + '%';
    }

    html += `
      <div class="ctx-card" style="border-left-color:${t.color}">
        <div class="ctx-task" style="color:${t.color}">${t.label}</div>
        <div class="ctx-rows">
          <div class="ctx-row">
            <span class="ctx-row-label">Raw</span>
            <span class="ctx-row-val" style="color:${t.color}">${raw.toExponential(1)} FLOPs</span>
          </div>
          <div class="ctx-row">
            <span class="ctx-row-label">Effective</span>
            <span class="ctx-row-val" style="color:${t.color}">${eff.toExponential(1)} FLOPs</span>
          </div>
          <div class="ctx-row">
            <span class="ctx-row-label">H100-yrs (raw)</span>
            <span class="ctx-row-val">${fmtH100(h100raw)}</span>
          </div>
          <div class="ctx-row">
            <span class="ctx-row-label">Cost (raw)</span>
            <span class="ctx-row-val">${fmtCost(costRaw)}</span>
          </div>
          <div class="ctx-row">
            <span class="ctx-row-label">% of frontier</span>
            <span class="ctx-row-val">${fmtPct(pctF)}</span>
          </div>
        </div>
      </div>
    `;
  }
  html += '</div>';
  document.getElementById(`ctx-${id}`).innerHTML = html;
}

// ─── Render task cards ────────────────────────────────────────────────────────
function renderCards(id) {
  const s = S[id];
  document.getElementById(`cards-${id}`).innerHTML = s.tasks.map(t => `
    <div class="tcard" style="border-left-color:${t.color}">
      <div class="tc-name" style="color:${t.color}">${t.label}</div>
      <div class="tc-aka">${t.aka}</div>
      <ul class="tc-bullets">
        ${t.bullets.map(b => `<li>${b}</li>`).join('')}
      </ul>
      <div class="tc-meta">
        <div class="tc-m">
          <span class="tc-ml">2024 baseline</span>
          <span class="tc-mv" style="color:${t.color}">${t.base.toExponential(0)}</span>
        </div>
        <div class="tc-m">
          <span class="tc-ml">Scale exp</span>
          <span class="tc-mv" style="color:${t.color}">${t.exp}</span>
        </div>
        <div class="tc-m">
          <span class="tc-ml">H100-yrs (2024)</span>
          <span class="tc-mv">${(t.base / H100_YR).toFixed(1)}</span>
        </div>
      </div>
      <div class="tc-note">${t.note}</div>
    </div>
  `).join('');
}

// ─── Controls ─────────────────────────────────────────────────────────────────
function setType(id, type) {
  US[id].type = type;
  ['raw','eff','both'].forEach(k => {
    document.getElementById(`c${id}-${k}`).classList.toggle('on',
      (k === 'raw' && type === 'raw') ||
      (k === 'eff' && type === 'eff') ||
      (k === 'both' && type === 'both')
    );
  });
  renderChart(id);
}

function setFrontier(id, show) {
  US[id].frontier = show;
  document.getElementById(`c${id}-fon`).classList.toggle('on', show);
  document.getElementById(`c${id}-foff`).classList.toggle('on', !show);
  renderChart(id);
}

function setRefs(id, show) {
  US[id].refs = show;
  document.getElementById(`c${id}-ron`).classList.toggle('on', show);
  document.getElementById(`c${id}-roff`).classList.toggle('on', !show);
  renderChart(id);
}

// ─── Tab switching ─────────────────────────────────────────────────────────────
function switchTab(id) {
  document.querySelectorAll('.tab').forEach((b, i)  => b.classList.toggle('on', i === id));
  document.querySelectorAll('.pane').forEach((p, i) => p.classList.toggle('on', i === id));
  setTimeout(() => Plotly.Plots.resize(`chart-${id}`), 40);
}

// ─── Methodology toggle ────────────────────────────────────────────────────────
function toggleMethod(btn) {
  btn.classList.toggle('open');
  btn.nextElementSibling.classList.toggle('open');
}

// ─── Init ──────────────────────────────────────────────────────────────────────
document.addEventListener('DOMContentLoaded', () => {
  for (let i = 0; i < 3; i++) {
    renderChart(i);
    renderContext(i);
    renderCards(i);
  }
});
</script>
</body>
</html>
